diff -urN EigenExa-1.0-RC5.orig/CMakeLists.txt EigenExa-1.0-RC5/CMakeLists.txt
--- EigenExa-1.0-RC5.orig/CMakeLists.txt	1970-01-01 09:00:00.000000000 +0900
+++ EigenExa-1.0-RC5/CMakeLists.txt	2013-06-13 19:53:11.000000000 +0900
@@ -0,0 +1,34 @@
+cmake_minimum_required(VERSION 2.8)
+project(EigenExa NONE)
+enable_language(C CXX Fortran)
+option(BUILD_SHARED_LIBS "Build shared libraries" ON)
+
+# RPATH setting
+if(APPLE)
+  set(CMAKE_INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/lib")
+else(APPLE)
+  set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib")
+  set(CMAKE_SKIP_BUILD_RPATH FALSE)
+  set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
+  set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
+endif(APPLE)
+
+# OpenMP
+find_package(OpenMP)
+if(OPENMP_FOUND)
+  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")
+  # Almost always OpenMP flags are same both for C and for Fortran.
+  set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} ${OpenMP_C_FLAGS}")
+endif(OPENMP_FOUND)
+
+# MPI library
+find_package(MPI)
+set(CMAKE_EXE_LINKER_FLAGS ${MPI_C_LINK_FLAGS})
+
+set(SOURCES eigen_prd.F eigen_prd_t1.F eigen_prd_t2.F eigen_prd_t4x.F eigen_prd_t5.F eigen_prd_t6_3.F eigen_prd_t7.F eigen_prd_t8.F dcx.F my_pdsxedc.F my_pdlaedz.F my_pdlaed0.F my_pdlaed1.F my_pdlaed2.F my_pdlaed3.F my_pdlasrt.F lapack_eigen.F dlaed3.F dlaed6.F dlaed6_init.F dc_redist1.F dc_redist2.F trbakwy4.F trbakwy4_body.F eigen_sx.F comm.F machine_epsilon.F matrix_adjustment.F CSTAB.F CSTAB_mem.c eigen_libs.F eigen_blacs.F eigen_devel.F eigen_house.F eigen_dc.F eigen_trbak.F dlaed6_common.F)
+add_library(EigenExa ${SOURCES})
+target_link_libraries(EigenExa ${SCALAPACK_LIB})
+install(TARGETS EigenExa ARCHIVE DESTINATION lib LIBRARY DESTINATION lib RUNTIME DESTINATION bin)
+
+add_executable(sample main2.f mat_set.f ev_test.f)
+target_link_libraries(sample EigenExa)
diff -urN EigenExa-1.0-RC5.orig/comm.F EigenExa-1.0-RC5/comm.F
--- EigenExa-1.0-RC5.orig/comm.F	2013-06-04 20:35:34.000000000 +0900
+++ EigenExa-1.0-RC5/comm.F	2013-06-13 19:50:36.000000000 +0900
@@ -658,3 +658,281 @@
        return
        end subroutine  datacast_dbl2
 
+
+       subroutine eigen_init( comm, order )
+*-
+!$     use OMP_LIB
+       use MPI
+       use eigen_devel
+       use eigen_blacs, only : eigen_blacs_init
+       implicit NONE
+*-
+       integer, intent(in), optional ::  comm
+       character*(*), intent(in), optional ::  order
+*-
+       integer                ::  n1, n2, n3, i, j, k, ierr
+       integer :: topo_type, cart_dim, dims(2), coords(2)
+       logical :: periods(2)
+       integer :: old_grp, new_grp
+
+       integer, pointer :: tmpgrid(:,:)
+       integer          :: group0, group1, kk0(1), kk1(1)
+
+       integer          :: local_size
+!$     integer          :: th0(2), th1(2)
+
+       character*1 :: GRID_major
+
+
+          call eigen_timer_reset( )
+
+          if ( PRESENT(comm) ) then
+             call MPI_Comm_dup( comm, TRD_COMM_WORLD, ierr )
+          else
+             call MPI_Comm_dup( MPI_COMM_WORLD, TRD_COMM_WORLD, ierr )
+          end if
+
+          call MPI_Comm_size( TRD_COMM_WORLD, TRD_nnod, ierr )
+          call MPI_Comm_rank( TRD_COMM_WORLD, TRD_inod, ierr )
+          TRD_inod = TRD_inod+1
+
+          call MPI_Topo_test( TRD_COMM_WORLD, topo_type, ierr )
+          if ( topo_type == MPI_CART ) then
+             call MPI_Cartdim_get( TRD_COMM_WORLD, cart_dim, ierr )
+          else
+             cart_dim = 1
+          end if
+
+       if ( cart_dim == 2 ) then
+
+          call MPI_Cart_get( TRD_COMM_WORLD, cart_dim,
+     &                       dims, periods, coords, ierr )
+          x_nnod = dims(1)
+          y_nnod = dims(2)
+          x_inod = coords(1)
+          y_inod = coords(2)
+
+          GRID_major = 'R'
+          if ( PRESENT(order) ) then
+          if ( x_inod == 1 .AND. y_inod == 1 ) then
+          if ( order(1:1) == 'C' .or. order(1:1) == 'c' ) then
+             print*,"********** CAUTION **********"
+             print*,"The MPI_CART you specified is based on R-major,"
+             print*,"but you also specified C-major option."
+             print*,"EigenExa solve this conflict by taking R-major."
+          end if
+          end if
+          end if
+
+       else
+
+          x_nnod = INT(SQRT(DBLE(TRD_nnod)))
+          i = 1 ! minimum factor, x_nnod must be multiple of k
+          if ( MOD(TRD_nnod, i) == 0 ) then
+             k = i
+          else
+             k = 1
+          end if
+          do
+             if ( x_nnod <= k ) exit
+             if ( MOD(x_nnod, k) == 0 .AND.
+     &            MOD(TRD_nnod, x_nnod) == 0 ) exit
+             x_nnod = x_nnod-1
+          end do!!
+          y_nnod = TRD_nnod/x_nnod
+
+          if ( PRESENT(order) ) then
+             GRID_major = order(1:1)
+          else
+             GRID_major = 'C'
+          end if
+
+          if ( GRID_major == 'R' .or. GRID_major == 'r' ) then
+             GRID_major = 'R'
+          else
+             GRID_major = 'C'
+          endif
+
+          call eigen_set_grid_major( GRID_major )
+
+          if ( GRID_major == 'R' ) then
+! row-major
+             x_inod =    (TRD_inod-1)/y_nnod +1
+             y_inod = MOD(TRD_inod-1, y_nnod)+1
+          else
+! column-major
+! ** EigenK adopts column-major in default
+!    The process ordering on the Earth Simulator was done in the way
+!    such as incrmental from internal processors to external nodes.
+!    We want to make the processes, which possess a distributed vector,
+!    close physically on the network connection.
+!    These are the historical reason to adopt column-major.
+             x_inod = MOD(TRD_inod-1, x_nnod)+1
+             y_inod =    (TRD_inod-1)/x_nnod +1
+          end if
+
+        end if
+
+          call MPI_Comm_split( TRD_COMM_WORLD, y_inod, x_inod,
+     &         x_COMM_WORLD, ierr )
+          call MPI_Comm_split( TRD_COMM_WORLD, x_inod, y_inod,
+     &         y_COMM_WORLD, ierr )
+
+!---- BLACS setup ---
+!#if TIMER_PRINT
+!          if ( x_inod == 1 .AND. y_inod == 1 ) then
+!             print*,"GRID major ",GRID_major," is specified."
+!          end if
+!#endif
+          call Eigen_BLACS_Init( TRD_COMM_WORLD, x_nnod, y_nnod,
+     &                           GRID_Major )
+
+!--------------------
+
+          n1 = MAX(x_nnod, y_nnod)
+          n2 = MIN(x_nnod, y_nnod)
+          do
+             if ( n1 == n2 ) then
+                n_common = n1
+                exit
+             end if
+             n3 = n1-n2
+             n1 = MAX(n2, n3)
+             n2 = MIN(n2, n3)
+          end do!!
+
+          if ( ASSOCIATED( p0_ ) ) then
+             deallocate( p0_ )
+          end if
+          allocate ( p0_(1:MAX(x_nnod, y_nnod)) )
+
+          if ( ASSOCIATED( q0_ ) ) then
+             deallocate( q0_ )
+          end if
+          allocate ( q0_(1:MAX(x_nnod, y_nnod)) )
+
+          p0_(:) = -1
+          q0_(:) = -1
+          do i = 1, x_nnod
+             if ( MOD(i-1, n_common) == MOD(y_inod-1, n_common) ) then
+                n1 = y_inod-i
+                if ( n1 >= 0 ) then
+                   do j = 1, x_nnod
+                      k = +n1+(j-1)*y_nnod
+                      if ( MOD(k, x_nnod) == 0 ) then
+                         p0_(i) = k/x_nnod
+                         q0_(i) = (j-1)
+                         exit
+                      end if
+                   end do! j
+                else
+                   do j = 1, y_nnod
+                      k = -n1+(j-1)*x_nnod
+                      if ( MOD(k, y_nnod) == 0 ) then
+                         q0_(i) = k/y_nnod
+                         p0_(i) = (j-1)
+                         exit
+                      end if
+                   end do! j
+                end if
+             end if
+          end do! i
+          p0_(:) = p0_(:)+1
+          q0_(:) = q0_(:)+1
+
+
+          diag_0 = 0
+          diag_1 = 0
+          do i = 1, y_nnod/n_common
+             j = (i-1)*y_nnod+y_inod
+             k = MOD(j-1, x_nnod)+1
+             if ( k == x_inod ) then
+                diag_0 = i
+                diag_1 = (j-1)/x_nnod+1
+                exit
+             end if
+          end do! i_1
+
+
+          if ( n_common > 1 ) then
+             i =          (x_inod-1)/ n_common
+             z_inod = MOD((x_inod-1), n_common)+1
+             z_nnod = n_common
+             call MPI_Comm_split( x_COMM_WORLD, i, z_inod-1,
+     &         z_COMM_WORLD, ierr )
+          else
+             z_COMM_WORLD = MPI_COMM_SELF
+             z_inod = 1
+             z_nnod = 1
+          end if
+
+!---- OpenMP thread check ---
+!$        call MPI_Query_thread( MPI_THREAD_MODE, ierr )
+!$        local_size = 1
+!$OMP PARALLEL
+!$OMP MASTER
+!$        local_size = omp_get_num_threads( )
+!$OMP END MASTER
+!$OMP END PARALLEL
+!$        th0(1) = local_size
+!$        th0(2) = -th0(1)
+!$        call MPI_Allreduce( th0, th1, 2, MPI_INTEGER, MPI_MAX,
+!$   &                        TRD_COMM_WORLD, ierr )
+!$        j = th1(1); k = -th1(2)
+!$        if ( j /= k ) then
+!$        if ( TRD_inod == 1 ) then
+!$           print*,"*************"
+!$           print*,"** CAUTION **"
+!$           print*,"*************"
+!$        print*,"EigenExa supports only homogeneous thread setting!"
+!$        if ( k == 1 ) then
+!$           print*,"EigenExa terminates this run."
+!$        else
+!$           print*,"EigenExa continues to compute, anyway."
+!$        print*,"But, accuracy of the result might be unacceptable."
+!$        end if
+!$           print*,"*************"
+!$        end if
+!$        if ( k == 1 ) then
+!$           call MPI_Abort( MPI_COMM_WORLD, 1, ierr )
+!$        end if
+!$        end if
+!--------------------
+
+       return
+       end subroutine  eigen_init
+
+
+!--
+      subroutine eigen_free( flag )
+      use MPI
+      use eigen_devel
+      use eigen_blacs, only : eigen_blacs_exit
+      implicit NONE
+      integer, intent(in), optional ::  flag
+*     -
+      integer                ::  ierr
+      
+      
+      call MPI_Comm_free( x_COMM_WORLD, ierr )
+      call MPI_Comm_free( y_COMM_WORLD, ierr )
+      
+      if ( n_common > 1 ) then
+         call MPI_Comm_free( z_COMM_WORLD, ierr )
+      end if
+      
+      deallocate ( p0_)
+      deallocate ( q0_)
+      
+      if ( PRESENT(flag) ) then
+         if ( flag == 1 ) call eigen_timer_print( )
+      end if
+      call eigen_timer_reset( )
+      
+      
+      TRD_COMM_WORLD = MPI_COMM_WORLD
+      
+      
+      return
+      end subroutine  eigen_free
+      
diff -urN EigenExa-1.0-RC5.orig/eigen_libs.F EigenExa-1.0-RC5/eigen_libs.F
--- EigenExa-1.0-RC5.orig/eigen_libs.F	2013-06-05 09:56:55.000000000 +0900
+++ EigenExa-1.0-RC5/eigen_libs.F	2013-06-13 19:50:36.000000000 +0900
@@ -15,6 +15,16 @@
           real(8), intent(inout) :: a(1:lda, *)
           real(8), intent(out)   :: w(*), z(1:ldz, *)
           end subroutine  eigen_sx
+
+          subroutine eigen_init( comm, order )
+          integer, intent(in), optional ::  comm
+          character*(*), intent(in), optional ::  order
+          end subroutine  eigen_init
+
+          subroutine eigen_free( flag )
+          integer, intent(in), optional ::  flag
+          end subroutine  eigen_free
+
 !--
        end interface
 
@@ -23,281 +33,6 @@
        contains
 !--
 !--
-       subroutine eigen_init( comm, order )
-*-
-!$     use OMP_LIB
-       use MPI
-       use eigen_devel
-       use eigen_blacs, only : eigen_blacs_init
-       implicit NONE
-*-
-       integer, intent(in), optional ::  comm
-       character*(*), intent(in), optional ::  order
-*-
-       integer                ::  n1, n2, n3, i, j, k, ierr
-       integer :: topo_type, cart_dim, dims(2), coords(2)
-       logical :: periods(2)
-       integer :: old_grp, new_grp
-
-       integer, pointer :: tmpgrid(:,:)
-       integer          :: group0, group1, kk0(1), kk1(1)
-
-       integer          :: local_size
-!$     integer          :: th0(2), th1(2)
-
-       character*1 :: GRID_major
-
-
-          call eigen_timer_reset( )
-
-          if ( PRESENT(comm) ) then
-             call MPI_Comm_dup( comm, TRD_COMM_WORLD, ierr )
-          else
-             call MPI_Comm_dup( MPI_COMM_WORLD, TRD_COMM_WORLD, ierr )
-          end if
-
-          call MPI_Comm_size( TRD_COMM_WORLD, TRD_nnod, ierr )
-          call MPI_Comm_rank( TRD_COMM_WORLD, TRD_inod, ierr )
-          TRD_inod = TRD_inod+1
-
-          call MPI_Topo_test( TRD_COMM_WORLD, topo_type, ierr )
-          if ( topo_type == MPI_CART ) then
-             call MPI_Cartdim_get( TRD_COMM_WORLD, cart_dim, ierr )
-          else
-             cart_dim = 1
-          end if
-
-       if ( cart_dim == 2 ) then
-
-          call MPI_Cart_get( TRD_COMM_WORLD, cart_dim,
-     &                       dims, periods, coords, ierr )
-          x_nnod = dims(1)
-          y_nnod = dims(2)
-          x_inod = coords(1)
-          y_inod = coords(2)
-
-          GRID_major = 'R'
-          if ( PRESENT(order) ) then
-          if ( x_inod == 1 .AND. y_inod == 1 ) then
-          if ( order(1:1) == 'C' .or. order(1:1) == 'c' ) then
-             print*,"********** CAUTION **********"
-             print*,"The MPI_CART you specified is based on R-major,"
-             print*,"but you also specified C-major option."
-             print*,"EigenExa solve this conflict by taking R-major."
-          end if
-          end if
-          end if
-
-       else
-
-          x_nnod = INT(SQRT(DBLE(TRD_nnod)))
-          i = 1 ! minimum factor, x_nnod must be multiple of k
-          if ( MOD(TRD_nnod, i) == 0 ) then
-             k = i
-          else
-             k = 1
-          end if
-          do
-             if ( x_nnod <= k ) exit
-             if ( MOD(x_nnod, k) == 0 .AND.
-     &            MOD(TRD_nnod, x_nnod) == 0 ) exit
-             x_nnod = x_nnod-1
-          end do!!
-          y_nnod = TRD_nnod/x_nnod
-
-          if ( PRESENT(order) ) then
-             GRID_major = order(1:1)
-          else
-             GRID_major = 'C'
-          end if
-
-          if ( GRID_major == 'R' .or. GRID_major == 'r' ) then
-             GRID_major = 'R'
-          else
-             GRID_major = 'C'
-          endif
-
-          call eigen_set_grid_major( GRID_major )
-
-          if ( GRID_major == 'R' ) then
-! row-major
-             x_inod =    (TRD_inod-1)/y_nnod +1
-             y_inod = MOD(TRD_inod-1, y_nnod)+1
-          else
-! column-major
-! ** EigenK adopts column-major in default
-!    The process ordering on the Earth Simulator was done in the way
-!    such as incrmental from internal processors to external nodes.
-!    We want to make the processes, which possess a distributed vector,
-!    close physically on the network connection.
-!    These are the historical reason to adopt column-major.
-             x_inod = MOD(TRD_inod-1, x_nnod)+1
-             y_inod =    (TRD_inod-1)/x_nnod +1
-          end if
-
-        end if
-
-          call MPI_Comm_split( TRD_COMM_WORLD, y_inod, x_inod,
-     &         x_COMM_WORLD, ierr )
-          call MPI_Comm_split( TRD_COMM_WORLD, x_inod, y_inod,
-     &         y_COMM_WORLD, ierr )
-
-!---- BLACS setup ---
-!#if TIMER_PRINT
-!          if ( x_inod == 1 .AND. y_inod == 1 ) then
-!             print*,"GRID major ",GRID_major," is specified."
-!          end if
-!#endif
-          call Eigen_BLACS_Init( TRD_COMM_WORLD, x_nnod, y_nnod,
-     &                           GRID_Major )
-
-!--------------------
-
-          n1 = MAX(x_nnod, y_nnod)
-          n2 = MIN(x_nnod, y_nnod)
-          do
-             if ( n1 == n2 ) then
-                n_common = n1
-                exit
-             end if
-             n3 = n1-n2
-             n1 = MAX(n2, n3)
-             n2 = MIN(n2, n3)
-          end do!!
-
-          if ( ASSOCIATED( p0_ ) ) then
-             deallocate( p0_ )
-          end if
-          allocate ( p0_(1:MAX(x_nnod, y_nnod)) )
-
-          if ( ASSOCIATED( q0_ ) ) then
-             deallocate( q0_ )
-          end if
-          allocate ( q0_(1:MAX(x_nnod, y_nnod)) )
-
-          p0_(:) = -1
-          q0_(:) = -1
-          do i = 1, x_nnod
-             if ( MOD(i-1, n_common) == MOD(y_inod-1, n_common) ) then
-                n1 = y_inod-i
-                if ( n1 >= 0 ) then
-                   do j = 1, x_nnod
-                      k = +n1+(j-1)*y_nnod
-                      if ( MOD(k, x_nnod) == 0 ) then
-                         p0_(i) = k/x_nnod
-                         q0_(i) = (j-1)
-                         exit
-                      end if
-                   end do! j
-                else
-                   do j = 1, y_nnod
-                      k = -n1+(j-1)*x_nnod
-                      if ( MOD(k, y_nnod) == 0 ) then
-                         q0_(i) = k/y_nnod
-                         p0_(i) = (j-1)
-                         exit
-                      end if
-                   end do! j
-                end if
-             end if
-          end do! i
-          p0_(:) = p0_(:)+1
-          q0_(:) = q0_(:)+1
-
-
-          diag_0 = 0
-          diag_1 = 0
-          do i = 1, y_nnod/n_common
-             j = (i-1)*y_nnod+y_inod
-             k = MOD(j-1, x_nnod)+1
-             if ( k == x_inod ) then
-                diag_0 = i
-                diag_1 = (j-1)/x_nnod+1
-                exit
-             end if
-          end do! i_1
-
-
-          if ( n_common > 1 ) then
-             i =          (x_inod-1)/ n_common
-             z_inod = MOD((x_inod-1), n_common)+1
-             z_nnod = n_common
-             call MPI_Comm_split( x_COMM_WORLD, i, z_inod-1,
-     &         z_COMM_WORLD, ierr )
-          else
-             z_COMM_WORLD = MPI_COMM_SELF
-             z_inod = 1
-             z_nnod = 1
-          end if
-
-!---- OpenMP thread check ---
-!$        call MPI_Query_thread( MPI_THREAD_MODE, ierr )
-!$        local_size = 1
-!$OMP PARALLEL
-!$OMP MASTER
-!$        local_size = omp_get_num_threads( )
-!$OMP END MASTER
-!$OMP END PARALLEL
-!$        th0(1) = local_size
-!$        th0(2) = -th0(1)
-!$        call MPI_Allreduce( th0, th1, 2, MPI_INTEGER, MPI_MAX,
-!$   &                        TRD_COMM_WORLD, ierr )
-!$        j = th1(1); k = -th1(2)
-!$        if ( j /= k ) then
-!$        if ( TRD_inod == 1 ) then
-!$           print*,"*************"
-!$           print*,"** CAUTION **"
-!$           print*,"*************"
-!$        print*,"EigenExa supports only homogeneous thread setting!"
-!$        if ( k == 1 ) then
-!$           print*,"EigenExa terminates this run."
-!$        else
-!$           print*,"EigenExa continues to compute, anyway."
-!$        print*,"But, accuracy of the result might be unacceptable."
-!$        end if
-!$           print*,"*************"
-!$        end if
-!$        if ( k == 1 ) then
-!$           call MPI_Abort( MPI_COMM_WORLD, 1, ierr )
-!$        end if
-!$        end if
-!--------------------
-
-       return
-       end subroutine  eigen_init
-!--
-          subroutine eigen_free( flag )
-          use MPI
-          use eigen_devel
-          use eigen_blacs, only : eigen_blacs_exit
-          implicit NONE
-          integer, intent(in), optional ::  flag
-*-
-          integer                ::  ierr
-
-
-             call MPI_Comm_free( x_COMM_WORLD, ierr )
-             call MPI_Comm_free( y_COMM_WORLD, ierr )
-
-             if ( n_common > 1 ) then
-             call MPI_Comm_free( z_COMM_WORLD, ierr )
-             end if
-
-             deallocate ( p0_)
-             deallocate ( q0_)
-
-             if ( PRESENT(flag) ) then
-                if ( flag == 1 ) call eigen_timer_print( )
-             end if
-             call eigen_timer_reset( )
-
-             call Eigen_BLACS_Exit( )
-
-             TRD_COMM_WORLD = MPI_COMM_WORLD
-
-
-          return
-          end subroutine  eigen_free
 !--
           subroutine eigen_get_matdims( n, nx, ny )
           use eigen_devel
